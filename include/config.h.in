/**
 * @file    config.h.in
 * @brief   config.h input file used by CMAKE
 * @details 
 * @author  David Hale <dhale@astro.caltech.edu>
 *
 * The file "config.h" is automatically generated by cmake.
 * Do not make any changes to config.h, as they will be overwritten by cmake!
 * Make changes only to config.h.in
 *
 */

#ifndef ARCHONCONFIG_H
#define ARCHONCONFIG_H

#include <fstream>
#include "logentry.h"

// Default CONFIG_FILE is set in CMakeLists.txt in the toplevel directory.
// Do not change it here.
//
#define CONFIG_FILE @CONFIG_FILE@

  class Config {
    private:
    public:
      Config(std::string filename_in): n_entries(), param(), arg() {
        this->filename = filename_in;
      };
      Config(): n_entries(), param(), arg() { };

      ~Config() { };

      std::string filename;
      int n_entries;
      std::vector<std::string> param;
      std::vector<std::string> arg;


      /** Archon::Server::read_config **********************************************/
      /**
       * @fn     read_config
       * @brief  read the configuration file
       * @param  reference to Config class object
       * @return ERROR or NO_ERROR
       *
       */
      long read_config(Config &config) {
        const char* function = "Config::read_config";
        std::fstream filestream;                                // I/O stream class
        std::string line;                                       // Temporary string to read file lines into
        size_t index1, index2;                                  // String indexing variables
        int linesread = 0;                                      // Counts the number of parameter lines read from file

        if ( !this->filename.empty() ) {
          filestream.open( this->filename, std::ios::in );
        }
        else {
          logwrite(function, "no config file specified");
          return(ERROR);
        }

        // Clear the vectors to load the new information from the config file
        //
        this->param.clear();
        this->arg.clear();

        while (getline(filestream, line)) {                     // Get a line from the file as long as they are available

          if (line.length() > 2) {                              // valid line is at least 3 characters, ie. X=Y

            if (line.at(0) == '#') continue;                    // If the first character is a #, ignore it.

            // At this point, all that is left to check are PARAM=ARG pairs, plus
            // possibly comments tagged on the end of the line.
            //
            else {
              index1 = line.find_first_of("=");                 // Find the = delimiter in the line
              this->param.push_back(line.substr(0, index1));    // Put the variable name into the vector holding the names

              // Look for configuration parameters in a vector format (i.e. surrounded by parentheses).
              //
              if ((index2 = line.find_last_of("(")) == std::string::npos){

                // Look for quotes around the variable value.  Quotes are required for
                // variables that have spaces in them (name strings for example).
                //
                if ((index2 = line.find_last_of("\"")) == std::string::npos){
                  // No quote strings, check for a comment at the end of the line
                  //
                  if ((index2 = line.find_first_of("#")) == std::string::npos){
                    // No comment, so get the index of the end of the comment and set the value into the vector.
                    //
                    index2 = line.find_first_of("\t\0");
                    this->arg.push_back(line.substr(index1+1, index2-index1));
                  }

                  // There is a comment, get the index and put the value (note the
                  // different index value for the line substring).
                  //
                  else {
                    index2 = line.find_first_of(" \t#");
                    this->arg.push_back(line.substr(index1+1, index2-index1-1));
                  }
                }

                // Quotes change the substring index again, so find the position of the
                // two quote characters in the string and get the value.
                //
                else {
                  index1 = line.find_first_of("\"") + 1;
                  index2 = line.find_last_of("\"");
                  this->arg.push_back(line.substr(index1, index2-index1));
                }
              }

              // A vector was found, so strip the part between the parentheses out and save it
              //
              else {
                index1 = line.find_first_of("(") + 1;
                index2 = line.find_last_of(")");
                this->arg.push_back(line.substr(index1, index2-index1));
              }
            }
          }
          else continue;                                        // For lines of less than 2 characters, we just loop to the next line

          linesread++;                                          // Increment the number of values read successfully
        }

        this->n_entries = linesread;                            // Set the number of elements to the number of lines read

        if (filestream.is_open() == true) {                     // Close the file stream
          filestream.flush();
          filestream.close();
        }

        return(NO_ERROR);

      }
      /** Archon::Server::read_config **********************************************/

  };
#endif
